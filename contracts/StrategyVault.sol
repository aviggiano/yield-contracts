//SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.8.6;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
import "./interfaces/IVault.sol";
import "./libs/TransferUtils.sol";
import "hardhat/console.sol";

contract StrategyVault is IVault, Ownable {
    using TransferUtils for IERC20Metadata;

    IERC20Metadata public immutable underlying;

    address strategist;

    uint totalDeposited;

    uint currentRoundId;
    mapping(address => uint) userRounds;

    mapping(address => uint) userShares;
    uint totalShares;

    mapping(address => uint) userLockedShares;
    uint totalLockedShares;

    mapping(address => uint) withdrawRequest;
    bool withdrawWindowOpen;

    constructor(address _underlying, address _strategist) {
        underlying = IERC20Metadata(_underlying);
        strategist = _strategist;
    }

    // Depositor
    function deposit(uint amount) public override {
        underlying.safeTransferFrom(msg.sender, address(this), amount);

        uint shareAmount = previewShares(amount);
        totalDeposited += amount;

        _unlockPreviousShares(msg.sender);
        _mintLockedShares(msg.sender, shareAmount);

        emit Deposit(msg.sender, shareAmount, amount);
    }

    function requestWithdraw(address owner) external {
        withdrawRequest[owner] = currentRoundId;
        emit WithdrawRequest(owner, currentRoundId);
    }

    function withdraw() public override {
        address owner = msg.sender;
        if (!withdrawWindowOpen) revert NotInWithdrawWindow();
        if (withdrawRequest[owner] != currentRoundId - 1) revert WithdrawNotAllowed();

        _unlockPreviousShares(owner);

        (uint shareAmount,) = sharesOf(owner);
        uint claimableUnderlying = previewClaim(shareAmount);

        _burnShares(owner, shareAmount);
        totalDeposited -= claimableUnderlying;
        underlying.transfer(owner, claimableUnderlying);

        emit Withdraw(owner, shareAmount, claimableUnderlying);
    }

    /**
     * @dev Outputs the amount of shares and the locked shares
     * for a given `owner` address
     */
    function sharesOf(address owner) public view returns (uint unlocked, uint locked) {
        locked = userLockedShares[owner];

        if (userRounds[owner] < currentRoundId) {
            locked = 0;
        }

        unlocked = userShares[owner] - locked;
    }

    /**
     * @dev Outputs the amount of shares that would be generated by depositing `underlyingAmount`
     */
    function previewShares(uint underlyingAmount) public view returns(uint) {
        uint shareAmount = underlyingAmount;

        if (totalShares > 0) {
            shareAmount = (underlyingAmount * totalShares) / totalDeposited;
        }

        return shareAmount;
    }

    /**
     * @dev Outputs the amount of underlying that would be claimed given the `shareAmount`
     */
    function previewClaim(uint shareAmount) public view returns(uint) {
        return (shareAmount * totalShares) / totalDeposited;
    }

    // Strategist

    modifier onlyStrategist {
        if(msg.sender != strategist) revert CallerIsNotTheStrategist();
        _;
    }

    function prepareRound() public onlyStrategist {
        withdrawWindowOpen = false;

        uint balance = underlying.balanceOf(address(this));
        underlying.safeTransfer(strategist, balance);

        emit PrepareRound(currentRoundId, balance);
    }

    function closeRound(uint amountYielded) public onlyStrategist {
        underlying.safeTransferFrom(msg.sender, address(this), amountYielded);
        withdrawWindowOpen = true;

        emit CloseRound(currentRoundId++, amountYielded);
    }

    /**
     * @dev Mint new shares, and locks them until they the next round
     * @param owner Address owner of the shares
     * @param shareAmount Amount of shares to lock
     */
    function _mintLockedShares(address owner, uint shareAmount) private {
        userShares[owner] += shareAmount;
        totalShares += shareAmount;

        userLockedShares[owner] += shareAmount;
        totalLockedShares += shareAmount;
    }

    /**
     * @dev Burn shares
     * @param owner Address owner of the shares
     * @param shareAmount Amount of shares to lock
     */
    function _burnShares(address owner, uint shareAmount) private {
        if (shareAmount > userShares[owner]) revert CallerHasNotEnoughShares();
        userShares[owner] -= shareAmount;
        totalShares -= shareAmount;
    }

    /**
     * @dev If owner has previous locked shares, unlocks them.
     * @param owner Address owner of the shares
     */
    function _unlockPreviousShares(address owner) private {
        if (userRounds[owner] < currentRoundId) {
            totalLockedShares -= userLockedShares[owner];
            userLockedShares[owner] = 0;
            userRounds[owner] = currentRoundId;
        }
    }
}
