//SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.8.6;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
import "./interfaces/IVault.sol";
import "./libs/TransferUtils.sol";

contract Vault is IVault, ERC20 {
    using TransferUtils for IERC20Metadata;

    IERC20Metadata public immutable underlying;

    constructor(string memory name, string memory symbol, address _underlying) ERC20(name, symbol) {
        underlying = IERC20Metadata(_underlying);
    }

    /**
     * @dev Deposits an asset in exchange of share of the Vault
     */
    function stake(uint amount) public virtual {
        underlying.safeTransferFrom(msg.sender, address(this), amount);

        uint shareAmount = previewShares(amount);
        _mint(msg.sender, shareAmount);

        afterStake(amount, shareAmount);

        emit Stake(msg.sender, shareAmount, amount);
    }

    /**
     * @dev Withdraws the staked assets
     */
    function claim() public virtual {
        uint shareAmount = balanceOf(msg.sender);
        if (shareAmount == 0) revert CallerHasNoShares();

        uint claimableUnderlying = previewClaim(shareAmount);

        beforeClaim(claimableUnderlying, shareAmount);
        _burn(msg.sender, shareAmount);

        underlying.transfer(msg.sender, claimableUnderlying);

        emit Claim(msg.sender, shareAmount, claimableUnderlying);
    }

    /**
     * @dev Outputs value of assets under management
     */
    function totalAssets() public view virtual returns(uint) {
        return underlying.balanceOf(address(this));
    }

    // Accounting

    /**
     * @dev Outputs the amount of shares that would be generated by depositing `underlyingAmount`
     */
    function previewShares(uint underlyingAmount) public view virtual returns(uint) {
        uint shareAmount = underlyingAmount;
        uint _totalSupply = totalSupply();

        if (_totalSupply > 0) {
            shareAmount = (underlyingAmount * _totalSupply) / underlying.balanceOf(address(this));
        }

        return shareAmount;
    }

    /**
     * @dev Outputs the amount of underlying that would be claimed given the `shareAmount`
     */
    function previewClaim(uint shareAmount) public view virtual returns(uint) {
        return (shareAmount * totalSupply()) / underlying.balanceOf(address(this));
    }

    // Hooks
    function afterStake(uint underlyingAmount, uint shareAmount) internal virtual {}
    function beforeClaim(uint underlyingAmount, uint shareAmount) internal virtual {}
}
